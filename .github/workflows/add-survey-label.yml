name: Add survey label to LATEST issue per player (OPEN issues)

on:
  workflow_dispatch:
    inputs:
      label_name:
        description: "Label to add (latest per player only)"
        required: true
        default: "survey"
      dry_run:
        description: "If true, only logs targets without editing"
        required: true
        default: "false"
      remove_label_from_older:
        description: "If true, remove the label from older duplicates (open issues only)"
        required: true
        default: "false"

permissions:
  issues: write

jobs:
  add_label:
    runs-on: ubuntu-latest
    steps:
      - name: Add label to latest per player among OPEN issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const labelName = (core.getInput('label_name') || 'survey').trim();
            const dryRun = (core.getInput('dry_run') || 'false').toLowerCase() === 'true';
            const removeOlder = (core.getInput('remove_label_from_older') || 'false').toLowerCase() === 'true';

            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            core.info(`Repo: ${owner}/${repo}`);
            core.info(`Label: ${labelName}`);
            core.info(`Dry-run: ${dryRun}`);
            core.info(`Remove label from older duplicates: ${removeOlder}`);

            // ----------------------------
            // Helpers
            // ----------------------------
            function labelNames(issue) {
              return (issue.labels || [])
                .map(l => typeof l === "string" ? l : l?.name)
                .filter(Boolean);
            }

            function extractJsonFromBody(body) {
              if (!body) return null;

              // Preferred: ```json ... ```
              const m = body.match(/```json\s*([\s\S]*?)\s*```/i);
              if (m && m[1]) {
                try { return JSON.parse(m[1]); } catch {}
              }

              // Fallback: find a JSON object containing "player_name"
              if (body.includes('"player_name"')) {
                const start = body.indexOf("{");
                if (start >= 0) {
                  const tail = body.slice(start);
                  const end = tail.lastIndexOf("}");
                  if (end >= 0) {
                    const candidate = tail.slice(0, end + 1);
                    try { return JSON.parse(candidate); } catch {}
                  }
                }
              }

              return null;
            }

            function cleanStr(v) {
              if (v == null) return "";
              return String(v).trim();
            }

            function getPlayerName(issue) {
              // 1) JSON body
              const data = extractJsonFromBody(issue.body || "");
              const pn = cleanStr(data?.player_name);
              if (pn) return pn;

              // 2) Title fallback: "Survey Response: <name>"
              //    (既存運用がこれなら拾える)
              const t = String(issue.title || "");
              const m = t.match(/^Survey Response:\s*(.+)\s*$/i);
              if (m && m[1]) return cleanStr(m[1]);

              return "";
            }

            // ---- 1) Ensure label exists (create if missing) ----
            async function ensureLabel() {
              try {
                await github.rest.issues.getLabel({ owner, repo, name: labelName });
                core.info(`Label "${labelName}" exists.`);
              } catch (e) {
                if (e.status === 404) {
                  if (dryRun) {
                    core.info(`[dry-run] Would create label "${labelName}"`);
                    return;
                  }
                  core.info(`Creating label "${labelName}"...`);
                  await github.rest.issues.createLabel({
                    owner, repo,
                    name: labelName,
                    color: "0e8a16",
                    description: "Survey response issue (latest per player)"
                  });
                  core.info(`Created label "${labelName}".`);
                } else {
                  throw e;
                }
              }
            }
            await ensureLabel();

            // ---- 2) Paginate all OPEN issues (excluding PRs) ----
            const per_page = 100;
            let page = 1;

            const openIssues = [];
            while (true) {
              const { data } = await github.rest.issues.listForRepo({
                owner, repo,
                state: "open",
                per_page,
                page
              });

              if (!data || data.length === 0) break;

              const issuesOnly = data.filter(x => !x.pull_request);
              openIssues.push(...issuesOnly);

              page++;
              if (page > 100) break; // safety
            }

            core.info(`Fetched open issues: ${openIssues.length}`);

            // ---- 3) Group by player_name, keep latest only ----
            // We will:
            //  - Determine player_name for each open issue
            //  - Skip issues with unknown player_name (to avoid mislabel)
            //  - For each player, pick the newest by created_at
            const byPlayer = new Map(); // player -> { latest: issue, others: issue[] }
            let unknownPlayerSkipped = 0;

            for (const issue of openIssues) {
              const player = getPlayerName(issue);

              if (!player) {
                unknownPlayerSkipped++;
                continue;
              }

              const created = new Date(issue.created_at).getTime();
              if (!byPlayer.has(player)) {
                byPlayer.set(player, { latest: issue, latestTime: created, others: [] });
              } else {
                const bucket = byPlayer.get(player);
                if (created > bucket.latestTime) {
                  bucket.others.push(bucket.latest);
                  bucket.latest = issue;
                  bucket.latestTime = created;
                } else {
                  bucket.others.push(issue);
                }
              }
            }

            core.info(`Players found: ${byPlayer.size}`);
            core.info(`Issues skipped (unknown player_name): ${unknownPlayerSkipped}`);

            // ---- 4) Apply labels: latest only ----
            let targets = 0;
            let labeled = 0;
            let alreadyHad = 0;

            // Optionally remove label from older duplicates
            let removeCandidates = 0;
            let removed = 0;
            let removeSkippedNotHave = 0;

            for (const [player, bucket] of byPlayer.entries()) {
              const latest = bucket.latest;
              const latestLabels = labelNames(latest);
              const hasLabel = latestLabels.includes(labelName);

              targets++;
              core.info(`LATEST for "${player}": #${latest.number} "${latest.title}" created_at=${latest.created_at}`);

              if (hasLabel) {
                alreadyHad++;
              } else {
                if (!dryRun) {
                  await github.rest.issues.addLabels({
                    owner, repo,
                    issue_number: latest.number,
                    labels: [labelName]
                  });
                  labeled++;
                } else {
                  core.info(`[dry-run] Would add label "${labelName}" to #${latest.number}`);
                }
              }

              if (removeOlder) {
                for (const oldIssue of bucket.others) {
                  removeCandidates++;
                  const oldLabels = labelNames(oldIssue);
                  const oldHas = oldLabels.includes(labelName);

                  if (!oldHas) {
                    removeSkippedNotHave++;
                    continue;
                  }

                  core.info(`OLDER for "${player}": #${oldIssue.number} "${oldIssue.title}" created_at=${oldIssue.created_at}`);

                  if (!dryRun) {
                    // remove label (REST: issues.removeLabel)
                    // If label doesn't exist, it will throw 404; but we checked oldHas so normally ok.
                    try {
                      await github.rest.issues.removeLabel({
                        owner, repo,
                        issue_number: oldIssue.number,
                        name: labelName
                      });
                      removed++;
                    } catch (e) {
                      // Be tolerant if GitHub returns 404 due to race conditions
                      core.warning(`Failed to remove label from #${oldIssue.number}: ${e.message}`);
                    }
                  } else {
                    core.info(`[dry-run] Would remove label "${labelName}" from #${oldIssue.number}`);
                  }
                }
              }
            }

            core.notice(
              `DONE: open_issues=${openIssues.length}, players=${byPlayer.size}, ` +
              `latest_targets=${targets}, labeled_latest=${labeled}, latest_already_had=${alreadyHad}, ` +
              `unknown_player_skipped=${unknownPlayerSkipped}, dry_run=${dryRun}`
            );

            if (removeOlder) {
              core.notice(
                `REMOVE-OLDER: candidates=${removeCandidates}, removed=${removed}, skipped_not_have_label=${removeSkippedNotHave}, dry_run=${dryRun}`
              );
            }
