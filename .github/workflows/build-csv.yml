name: Build Survey CSV

on:
  workflow_dispatch:
  schedule:
    - cron: "0 18 * * *"   # UTC 18:00 → JST 翌日 03:00

jobs:
  rebuild:
    runs-on: ubuntu-latest

    concurrency:
      group: survey-csv
      cancel-in-progress: false

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Rebuild data/survey.csv from issues (survey: + old title)
        id: rebuild
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            const headers = [
              'timestamp',
              'language',
              'player_name',
              'Q2_time',
              'Q3_time',
              'Q4_day',
            ];

            const ALLOWED_LANGS = new Set([
              "en","de","nl","fr","ru","es","pt","it","zh-hans","ja","ko","zh-hant","ar","th","vi","tr","pl","ms","id"
            ]);

            function escapeCSV(value) {
              if (value == null) return '';
              const s = String(value);
              if (/[",\n]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
              return s;
            }

            function normalizeLang(v) {
              const s = (v == null ? '' : String(v)).trim().toLowerCase();
              if (!s) return 'en';
              if (s === 'zh') return 'zh-hans';
              if (!ALLOWED_LANGS.has(s)) return 'en';
              return s;
            }

            // Supports BOTH formats:
            // A) key: value lines (new Functions format)
            // B) | key | value | table lines (old format)
            function parseIssueBody(body) {
              const lines = (body || '').split(/\r?\n/);
              const map = {};

              for (const line of lines) {
                // B) Markdown table
                let m = line.match(/^\s*\|\s*([^|]+?)\s*\|\s*(.*?)\s*\|\s*$/);
                if (m) {
                  map[m[1].trim()] = m[2].trim();
                  continue;
                }
                // A) key: value
                m = line.match(/^\s*([A-Za-z0-9_]+)\s*:\s*(.*?)\s*$/);
                if (m) {
                  map[m[1].trim()] = m[2].trim();
                  continue;
                }
              }

              const rowObject = {
                timestamp: map['timestamp'] || '',
                language: normalizeLang(map['language']),
                player_name: map['player_name'] || '',
                Q2_time: map['Q2_time'] || map['Q02_time'] || map['Q02 (time)'] || '',
                Q3_time: map['Q3_time'] || map['Q03_time'] || map['Q03 (time)'] || '',
                Q4_day: map['Q4_day'] || map['Q04_day'] || map['Q04 (day)'] || '',
              };

              const hasValue = Object.values(rowObject).some(v => (v || '') !== '');
              return hasValue ? rowObject : null;
            }

            core.info(`Fetching ALL issues...`);

            const issues = await github.paginate(
              github.rest.issues.listForRepo,
              { owner, repo, state: 'all', per_page: 100 }
            );

            const latestByPlayer = new Map();

            for (const issue of issues) {
              if (issue.pull_request) continue;

              const title = issue.title || "";
              const isOld = title.startsWith("Survey response from:");
              const isNew = title.startsWith("survey:");
              if (!isOld && !isNew) continue;

              const rowObject = parseIssueBody(issue.body || '');
              if (!rowObject?.player_name) continue;

              const key = rowObject.player_name;
              const createdAt = new Date(issue.created_at);

              const existing = latestByPlayer.get(key);
              if (!existing || createdAt > existing.createdAt) {
                latestByPlayer.set(key, { createdAt, row: rowObject });
              }
            }

            const finalRows = [...latestByPlayer.values()]
              .sort((a, b) => a.createdAt - b.createdAt)
              .map(e => e.row);

            const dataDir = path.join(process.cwd(), 'data');
            fs.mkdirSync(dataDir, { recursive: true });

            const csvPath = path.join(dataDir, 'survey.csv');

            let csv = headers.join(',');
            if (finalRows.length) {
              csv += '\n' + finalRows
                .map(r => headers.map(h => escapeCSV(r[h])).join(','))
                .join('\n');
            }
            csv += '\n';

            fs.writeFileSync(csvPath, csv, 'utf8');

            core.setOutput('csv_path', csvPath);
            core.setOutput('row_count', finalRows.length);

      - name: Commit and push changes (with rebase & retry)
        env:
          BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          git config user.name "${GITHUB_ACTOR}"
          git config user.email "${GITHUB_ACTOR}@users.noreply.github.com"

          git add data/survey.csv
          if git diff --cached --quiet; then
            echo "No updates to commit."
            exit 0
          fi

          git commit -m "Nightly rebuild survey.csv"

          for i in 1 2 3 4 5; do
            git pull --rebase origin "$BRANCH" || true
            if git push origin HEAD:"$BRANCH"; then
              echo "Push success"
              exit 0
            fi
            echo "Push failed, retry $i..."
            sleep 2
          done

          echo "Push failed after retries"
          exit 1
