name: Collect survey responses

on:
  issues:
    types: [opened]

jobs:
  collect:
    # アンケート以外の Issue では動かさない
    if: startsWith(github.event.issue.title, 'Survey response from:')
    runs-on: ubuntu-latest

    # CSV を触るジョブは常に 1 本だけ
    concurrency:
      group: survey-csv
      cancel-in-progress: false

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Update data/survey.csv from this issue
        id: update
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const issue = context.payload.issue;

            const headers = [
              'timestamp',
              'language',
              'player_name',
              'Q2_time',
              'Q3_time',
              'Q4_day',
            ];

            function escapeCSV(value) {
              if (value == null) return '';
              const s = String(value);
              if (/[",\n]/.test(s)) {
                return `"${s.replace(/"/g, '""')}"`;
              }
              return s;
            }

            function parseIssueBody(body) {
              const lines = (body || '').split(/\r?\n/);
              const map = {};

              for (const line of lines) {
                // 例: "| timestamp | 2025-12-10T12:34:56Z |"
                const m = line.match(/^\s*\|\s*([^|]+?)\s*\|\s*(.*?)\s*\|\s*$/);
                if (m) {
                  const key = m[1].trim();
                  const value = m[2].trim();
                  map[key] = value;
                }
              }

              const rowObject = {
                timestamp: map['timestamp'] || '',
                language: map['language'] || '',
                player_name: map['player_name'] || '',
                Q2_time: map['Q2_time'] || map['Q02_time'] || '',
                Q3_time: map['Q3_time'] || map['Q03_time'] || '',
                Q4_day: map['Q4_day'] || map['Q04_day'] || '',
              };

              const hasValue = Object.values(rowObject).some(
                (v) => (v || '') !== ''
              );
              return hasValue ? rowObject : null;
            }

            const rowObject = parseIssueBody(issue.body || '');
            if (!rowObject) {
              core.info(`Issue #${issue.number}: no valid survey body, skip.`);
              core.setOutput('changed', 'false');
              return;
            }

            if (!rowObject.player_name) {
              core.info(`Issue #${issue.number}: player_name is empty, skip.`);
              core.setOutput('changed', 'false');
              return;
            }

            core.info(`Updating CSV for player: ${rowObject.player_name}`);

            const dataDir = path.join(process.cwd(), 'data');
            fs.mkdirSync(dataDir, { recursive: true });

            const csvPath = path.join(dataDir, 'survey.csv');

            // 既存 CSV を読み込み
            let existingRows = [];
            if (fs.existsSync(csvPath)) {
              const content = fs.readFileSync(csvPath, 'utf8').trim();
              if (content) {
                const lines = content.split(/\r?\n/);
                const headerLine = lines[0];

                // ヘッダーが予想と違っても、できるだけ読み取る
                for (let i = 1; i < lines.length; i++) {
                  const line = lines[i].trim();
                  if (!line) continue;
                  // プレイヤー名などにカンマが含まれない前提で簡易パース
                  const cols = line.split(',');
                  existingRows.push({
                    timestamp: cols[0] || '',
                    language: cols[1] || '',
                    player_name: cols[2] || '',
                    Q2_time: cols[3] || '',
                    Q3_time: cols[4] || '',
                    Q4_day: cols[5] || '',
                  });
                }
              }
            }

            // 同じ player_name は最新のものだけ残す
            const mapByPlayer = new Map();
            for (const r of existingRows) {
              if (!r.player_name) continue;
              mapByPlayer.set(r.player_name, r);
            }
            // 今回の回答で上書き
            mapByPlayer.set(rowObject.player_name, rowObject);

            // マップから配列へ（順番は特にこだわらない）
            const finalRows = Array.from(mapByPlayer.values());

            let csv = headers.join(',');
            if (finalRows.length > 0) {
              csv += '\n' + finalRows
                .map(r => headers.map(h => escapeCSV(r[h])).join(','))
                .join('\n');
            }
            csv += '\n';

            fs.writeFileSync(csvPath, csv, 'utf8');

            core.setOutput('changed', 'true');
            core.setOutput('csv_path', csvPath);
            core.setOutput('player_name', rowObject.player_name);

      - name: Show summary
        if: steps.update.outputs.changed == 'true'
        run: |
          echo "Updated CSV: ${{ steps.update.outputs.csv_path }}"
          echo "Player: ${{ steps.update.outputs.player_name }}"

      - name: Commit and push CSV
        if: steps.update.outputs.changed == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          git config user.name "${GITHUB_ACTOR}"
          git config user.email "${GITHUB_ACTOR}@users.noreply.github.com"

          git add data/survey.csv

          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi

          git commit -m "Update survey.csv from issue #${{ github.event.issue.number }}"

          # 他のジョブが push していても rebase してから push
          git pull --rebase origin "$BRANCH" || true
          git push origin HEAD:"$BRANCH"
